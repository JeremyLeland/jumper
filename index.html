<head>
  <title>Jumper</title>
  <link rel="stylesheet" href="../style.css">
</head>

<body>
</body>

<script type="module">

  import * as THREE from '../lib/three.module.js';
  import { ThreeGame } from '../src/ThreeGame.js';
  import { Level } from '../src/Level.js';

  const LEVEL_COLS = 9;

  const CAMERA_X = LEVEL_COLS * Level.BLOCK_WIDTH / 2;
  const CAMERA_Y = 3;
  const CAMERA_FOLLOW_Z = 4;
  const CAMERA_LOOK_Z = -3;

  const LIGHT_X = CAMERA_X;
  const LIGHT_Y = 10;
  const LIGHT_FOLLOW_Z = 5;

  const PLAYER_SIDE_SPEED = 0.008;
  const PLAYER_SIZE = 0.4;

  const scene = new THREE.Scene();
  scene.background = new THREE.Color( 0x111122 ); 

  const light = new THREE.DirectionalLight( 0xffffff );

  //
  // TODO: Figure out how this works, tune as needed
  //
  light.castShadow = true;

  // const dLight = 200;
  // const sLight = dLight * 0.25;
  // light.shadow.camera.left = - sLight;
  // light.shadow.camera.right = sLight;
  // light.shadow.camera.top = sLight;
  // light.shadow.camera.bottom = - sLight;

  // light.shadow.camera.near = dLight / 30;
  // light.shadow.camera.far = dLight;

  light.shadow.mapSize.width = 1024 * 2;
  light.shadow.mapSize.height = 1024 * 2;

  // light.shadow.camera.visible = true;

  // scene.add(new THREE.CameraHelper(light.shadow.camera));
  //
  //
  //

  scene.add( light );
  scene.add( light.target );

  const player = new THREE.Mesh(
    new THREE.SphereGeometry( PLAYER_SIZE, 20, 20 ),
    new THREE.MeshPhongMaterial( {
      color: 0xffffff, 
      transparent: true, 
      opacity: 0.8
    } )
  );
  player.castShadow = true;
  player.receiveShadow = false;
  scene.add( player );
  
  const game = new ThreeGame();
  game.renderer.shadowMap.enabled = true;
  game.renderer.shadowMap.soft = true;
  game.scene = scene;

  let level;
  loadLevel( './levels/classic/03.png' );

  async function loadLevel( src ) {
    if ( level ) {
      scene.remove( level.mesh );
      level.mesh.geometry.dispose();
      level.mesh.material.dispose();
    }
    
    level = await Level.fromImageSrc( src );
  
    
    scene.add( level.mesh );

    // TODO: Spawn higher so we fall from off screen
    player.position.set( ( level.cols / 2 ) * Level.BLOCK_WIDTH, PLAYER_SIZE, ( level.rows - 0.5 ) * Level.BLOCK_LENGTH );

    light.position.set( player.position.x, LIGHT_Y, player.position.z + LIGHT_FOLLOW_Z );
    light.target.position.set( LIGHT_X, 0, player.position.z );

    game.camera.position.set( CAMERA_X, CAMERA_Y, player.position.z + CAMERA_FOLLOW_Z );
    game.camera.lookAt( player.position.x, 0, player.position.z + CAMERA_LOOK_Z );

  }

  game.update = ( dt ) => {
    if ( game.keysPressed.has( 'ArrowLeft' ) ) {
      player.position.x -= PLAYER_SIDE_SPEED * dt;
    }
    if ( game.keysPressed.has( 'ArrowRight' ) ) {
      player.position.x += PLAYER_SIDE_SPEED * dt;
    }
  }

  //
  // Drag and drop to load levels
  //
  window.ondragover = ( event ) => {
    event.preventDefault();
  }
  window.ondrop = ( event ) => {
    event.preventDefault();

    if ( event.dataTransfer.items ) {
      for ( let i = 0; i < event.dataTransfer.items.length; i ++ ) {
        if ( event.dataTransfer.items[ i ].kind === 'file' ) {
          const file = event.dataTransfer.items[ i ].getAsFile();
          const reader = new FileReader();
          reader.onloadend = () => {
            loadLevel( reader.result );
          };
          reader.readAsDataURL( file );
        }
      }
    }
    else {
      for ( let i = 0; i < event.dataTransfer.files.length; i ++ ) {
        loadLevel( event.dataTransfer.files[ i ].name );
      }
    }
  }

</script>